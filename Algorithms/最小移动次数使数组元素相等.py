# -*- coding: utf-8 -*-
"""
Created on Thu Aug 23 07:56:50 2018

@author: xiaohong
"""

'''
给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。
每次移动可以使 n - 1 个元素增加 1。

示例:

输入:
[1,2,3]

输出:
3

解释:
只需要3次移动（注意每次移动会增加两个元素的值）：

[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
'''

'''
别人的 时间复杂度O(n) 空间复杂度O(1) 0.6
思路： 问题可以转化成将数组中比最小值大的元素每一次减一，注意，每一次只对比最小值大
    的一个元素进行减一操作，这样问题就转化为计算数组中，其他元素与最小值的差的和
'''


def minMoves(nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        minmum = min(nums)
        return sum([i-minmum  for i in nums ])
            
'''
更简答的 时间复杂度O(1) 空间复杂度O(1) 1
思路： 问题可以转化成将数组中比最小值大的元素每一次减一，注意，每一次只对比最小值大
    的一个元素进行减一操作，这样问题就转化为计算数组中，其他元素与最小值的差的和
    既然最终状态是数组的值都是最小值，并且每一步是一个元素减一，那就直接可以用元数组
    的和减去最终状态数组的和
'''

def minMoves(nums):
        """
        :type nums: List[int]
        :rtype: int
        """               
        return sum(nums) - len(nums) * min(nums)
        
        
        
        
        
        
        